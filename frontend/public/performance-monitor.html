<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frontend Performance Monitor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .monitor { background: white; padding: 20px; margin: 10px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .metric { display: flex; justify-content: space-between; margin: 10px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; }
        .good { color: #28a745; }
        .warning { color: #ffc107; }
        .danger { color: #dc3545; }
        .chart { height: 200px; background: #f8f9fa; margin: 10px 0; border-radius: 4px; display: flex; align-items: center; justify-content: center; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #0056b3; }
        .status-indicator { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .log { background: #f8f9fa; padding: 10px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>
    <h1>üéØ Frontend Performance Monitor</h1>
    <p>Real-time monitoring of React application performance</p>

    <div class="monitor">
        <h2>üìä Performance Metrics</h2>
        <div class="metric">
            <span>Page Load Time:</span>
            <span id="pageLoadTime" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>DOM Content Loaded:</span>
            <span id="domContentLoaded" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>First Contentful Paint:</span>
            <span id="firstContentfulPaint" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>Largest Contentful Paint:</span>
            <span id="largestContentfulPaint" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>Cumulative Layout Shift:</span>
            <span id="cumulativeLayoutShift" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>First Input Delay:</span>
            <span id="firstInputDelay" class="good">Loading...</span>
        </div>
    </div>

    <div class="monitor">
        <h2>üß† Memory Usage</h2>
        <div class="metric">
            <span>Used JS Heap:</span>
            <span id="usedJSHeapSize" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>Total JS Heap:</span>
            <span id="totalJSHeapSize" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>JS Heap Limit:</span>
            <span id="jsHeapSizeLimit" class="good">Loading...</span>
        </div>
        <div class="metric">
            <span>Memory Usage:</span>
            <span id="memoryUsagePercent" class="good">Loading...</span>
        </div>
    </div>

    <div class="monitor">
        <h2>üåê Network Performance</h2>
        <div class="metric">
            <span>API Health Check:</span>
            <span id="apiHealth"><span class="status-indicator" style="background: #ffc107;"></span>Testing...</span>
        </div>
        <div class="metric">
            <span>Board API Response:</span>
            <span id="boardApi"><span class="status-indicator" style="background: #ffc107;"></span>Testing...</span>
        </div>
        <div class="metric">
            <span>Tickets API Response:</span>
            <span id="ticketsApi"><span class="status-indicator" style="background: #ffc107;"></span>Testing...</span>
        </div>
        <div class="metric">
            <span>WebSocket Connection:</span>
            <span id="websocketStatus"><span class="status-indicator" style="background: #ffc107;"></span>Testing...</span>
        </div>
    </div>

    <div class="monitor">
        <h2>‚ö° React Performance</h2>
        <div class="metric">
            <span>Component Render Count:</span>
            <span id="renderCount" class="good">0</span>
        </div>
        <div class="metric">
            <span>Average Render Time:</span>
            <span id="avgRenderTime" class="good">0ms</span>
        </div>
        <div class="metric">
            <span>Slow Renders (>16ms):</span>
            <span id="slowRenders" class="good">0</span>
        </div>
        <div class="metric">
            <span>Bundle Size Estimate:</span>
            <span id="bundleSize" class="good">Calculating...</span>
        </div>
    </div>

    <div class="monitor">
        <h2>üéõÔ∏è Controls</h2>
        <button onclick="runPerformanceTest()">Run Performance Test</button>
        <button onclick="simulateLoad()">Simulate Load</button>
        <button onclick="checkMemoryLeaks()">Check Memory Leaks</button>
        <button onclick="exportReport()">Export Report</button>
        <button onclick="clearLogs()">Clear Logs</button>
    </div>

    <div class="monitor">
        <h2>üìù Performance Log</h2>
        <div id="performanceLog" class="log">Starting performance monitoring...\n</div>
    </div>

    <script>
        let performanceData = {
            renders: [],
            memorySnapshots: [],
            networkRequests: [],
            startTime: Date.now()
        };

        function log(message, type = 'info') {
            const logDiv = document.getElementById('performanceLog');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
            logDiv.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTime(milliseconds) {
            return `${milliseconds.toFixed(2)}ms`;
        }

        function getStatusClass(value, good, warning) {
            if (value <= good) return 'good';
            if (value <= warning) return 'warning';
            return 'danger';
        }

        function updateWebVitals() {
            // Get performance navigation timing
            const navigation = performance.getEntriesByType('navigation')[0];
            if (navigation) {
                const pageLoadTime = navigation.loadEventEnd - navigation.loadEventStart;
                const domContentLoaded = navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart;

                document.getElementById('pageLoadTime').textContent = formatTime(pageLoadTime);
                document.getElementById('pageLoadTime').className = getStatusClass(pageLoadTime, 1000, 3000);

                document.getElementById('domContentLoaded').textContent = formatTime(domContentLoaded);
                document.getElementById('domContentLoaded').className = getStatusClass(domContentLoaded, 500, 1500);
            }

            // Get paint timing
            const paintEntries = performance.getEntriesByType('paint');
            paintEntries.forEach(entry => {
                if (entry.name === 'first-contentful-paint') {
                    document.getElementById('firstContentfulPaint').textContent = formatTime(entry.startTime);
                    document.getElementById('firstContentfulPaint').className = getStatusClass(entry.startTime, 1000, 2500);
                }
            });

            // Get LCP if available
            if ('web-vitals' in window) {
                // This would require importing web-vitals library
                log('Web Vitals library not available, using basic metrics');
            }
        }

        function updateMemoryInfo() {
            if (performance.memory) {
                const memory = performance.memory;
                const usedPercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;

                document.getElementById('usedJSHeapSize').textContent = formatBytes(memory.usedJSHeapSize);
                document.getElementById('totalJSHeapSize').textContent = formatBytes(memory.totalJSHeapSize);
                document.getElementById('jsHeapSizeLimit').textContent = formatBytes(memory.jsHeapSizeLimit);

                document.getElementById('memoryUsagePercent').textContent = `${usedPercent.toFixed(1)}%`;
                document.getElementById('memoryUsagePercent').className = getStatusClass(usedPercent, 50, 80);

                // Store memory snapshot
                performanceData.memorySnapshots.push({
                    timestamp: Date.now(),
                    used: memory.usedJSHeapSize,
                    total: memory.totalJSHeapSize,
                    limit: memory.jsHeapSizeLimit
                });

                // Keep only last 100 snapshots
                if (performanceData.memorySnapshots.length > 100) {
                    performanceData.memorySnapshots = performanceData.memorySnapshots.slice(-100);
                }
            } else {
                log('Memory API not available in this browser', 'warning');
            }
        }

        async function testNetworkPerformance() {
            const tests = [
                { id: 'apiHealth', url: '/api/health', name: 'API Health' },
                { id: 'boardApi', url: '/api/boards/1', name: 'Board API' },
                { id: 'ticketsApi', url: '/api/boards/1/tickets', name: 'Tickets API' }
            ];

            for (const test of tests) {
                const element = document.getElementById(test.id);
                const indicator = element.querySelector('.status-indicator');

                try {
                    const start = performance.now();
                    const response = await fetch(test.url);
                    const duration = performance.now() - start;

                    const success = response.ok;
                    indicator.style.background = success ? '#28a745' : '#dc3545';
                    element.innerHTML = `<span class="status-indicator" style="background: ${success ? '#28a745' : '#dc3545'};"></span>${formatTime(duration)} (${response.status})`;
                    element.className = getStatusClass(duration, 100, 500);

                    performanceData.networkRequests.push({
                        timestamp: Date.now(),
                        test: test.name,
                        duration,
                        status: response.status,
                        success
                    });

                    log(`${test.name}: ${formatTime(duration)} (HTTP ${response.status})`, success ? 'success' : 'error');
                } catch (error) {
                    indicator.style.background = '#dc3545';
                    element.innerHTML = `<span class="status-indicator" style="background: #dc3545;"></span>Error: ${error.message}`;
                    element.className = 'danger';
                    log(`${test.name} failed: ${error.message}`, 'error');
                }
            }
        }

        function estimateBundleSize() {
            // Estimate based on script tags and resources
            const scripts = document.querySelectorAll('script[src]');
            const links = document.querySelectorAll('link[rel="stylesheet"]');

            let totalEstimate = 0;
            scripts.forEach(script => {
                // Basic estimation - actual size would need network measurement
                totalEstimate += 100; // KB estimate per script
            });

            links.forEach(link => {
                totalEstimate += 20; // KB estimate per stylesheet
            });

            document.getElementById('bundleSize').textContent = `~${totalEstimate}KB (estimated)`;
            document.getElementById('bundleSize').className = getStatusClass(totalEstimate, 500, 1000);
        }

        function runPerformanceTest() {
            log('Starting comprehensive performance test...', 'info');
            updateWebVitals();
            updateMemoryInfo();
            testNetworkPerformance();
            estimateBundleSize();
            log('Performance test completed', 'success');
        }

        function simulateLoad() {
            log('Simulating high load scenario...', 'warning');

            // Create some work to simulate load
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const start = performance.now();
                    // Simulate some CPU work
                    let result = 0;
                    for (let j = 0; j < 100000; j++) {
                        result += Math.random();
                    }
                    const duration = performance.now() - start;
                    log(`Load simulation ${i + 1}/10: ${formatTime(duration)}`);

                    if (i === 9) {
                        updateMemoryInfo();
                        log('Load simulation completed', 'success');
                    }
                }, i * 500);
            }
        }

        function checkMemoryLeaks() {
            log('Checking for potential memory leaks...', 'info');

            if (performanceData.memorySnapshots.length < 2) {
                log('Need more memory snapshots to detect leaks', 'warning');
                return;
            }

            const recent = performanceData.memorySnapshots.slice(-10);
            const trend = recent[recent.length - 1].used - recent[0].used;

            if (trend > 1024 * 1024) { // 1MB increase
                log(`Potential memory leak detected: ${formatBytes(trend)} increase`, 'error');
            } else {
                log('No significant memory leaks detected', 'success');
            }
        }

        function exportReport() {
            const report = {
                timestamp: new Date().toISOString(),
                duration: Date.now() - performanceData.startTime,
                memorySnapshots: performanceData.memorySnapshots,
                networkRequests: performanceData.networkRequests,
                renders: performanceData.renders,
                currentMetrics: {
                    pageLoadTime: document.getElementById('pageLoadTime').textContent,
                    memoryUsage: document.getElementById('memoryUsagePercent').textContent,
                    bundleSize: document.getElementById('bundleSize').textContent
                }
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `performance-report-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            log('Performance report exported', 'success');
        }

        function clearLogs() {
            document.getElementById('performanceLog').innerHTML = 'Logs cleared...\n';
            performanceData.renders = [];
            performanceData.memorySnapshots = [];
            performanceData.networkRequests = [];
            log('Performance monitoring reset', 'info');
        }

        // Initialize monitoring
        window.addEventListener('load', () => {
            log('Performance monitor initialized', 'success');
            runPerformanceTest();

            // Set up periodic monitoring
            setInterval(() => {
                updateMemoryInfo();
                testNetworkPerformance();
            }, 30000); // Every 30 seconds

            // Monitor for long tasks
            if ('PerformanceObserver' in window) {
                const observer = new PerformanceObserver((list) => {
                    list.getEntries().forEach((entry) => {
                        if (entry.duration > 50) { // Long task threshold
                            log(`Long task detected: ${formatTime(entry.duration)}`, 'warning');
                        }
                    });
                });
                observer.observe({ entryTypes: ['longtask'] });
            }
        });

        // Monitor React rendering if DevTools are available
        if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
            log('React DevTools detected - enhanced monitoring available', 'success');
        }
    </script>
</body>
</html>
